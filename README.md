# SW Expert Academy 1244. 최대 상금
> [문제링크][link]

[link]: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15Khn6AN0CFAYD&categoryId=AV15Khn6AN0CFAYD&categoryType=CODE&problemTitle=1244&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1 "link"

<br/>

---

<br/>

## i. 문제
> ![문제1](/images/문제1.PNG)
> ![문제2](/images/문제2.PNG)

<br/>

---

<br/>

## ii. 코드
>``` Java
>import java.io.BufferedReader;
>import java.io.InputStreamReader;
>import java.util.StringTokenizer;
> 
>class Solution
>{
>	public static int result;
>	
>	public static void main(String args[]) throws Exception
>	{
>		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
>
>		// 반복할 테스트 케이스 횟수
>		int T = Integer.parseInt(br.readLine());
>
>		// 테스트 케이스 수만큼 반복
>		for(int test_case = 1; test_case <= T; test_case++) {
>			
>			StringTokenizer st = new StringTokenizer(br.readLine());
>		
>			// 처음 숫자
>			int number = Integer.parseInt(st.nextToken());
>			
>			// 교환해야하는 횟수
>			int C = Integer.parseInt(st.nextToken());
>			
>			// 처음 숫자를 문자의 배열로 변환
>			char[] numbers = Integer.toString(number).toCharArray();
>			
>			// 정답 초기화
>			result = 0;
>			
>			// -----------------------------------------------------------------
>			// --- 1. 완전 탐색을 시작하기 전 의미없는 교환 횟수를 제거한다. ---
>			int N = numbers.length;
>			if (N-1 < C) 
>				C = (N-1) - ((C - (N-1)) % 2);
>			// -----------------------------------------------------------------
>			
>			// 완전탐색 수행
>			dfs(C,0, numbers);
>            
>			// 정답 출력
>			System.out.println("#" + test_case + " " + result);
>            
>		}
>		
>	}
>	
>	// 완전 탐색
>	public static void dfs(int cnt, int start, char[] numbers) {
>		
>		// 교환 횟수를 전부 수행했다면 종료
>		if(cnt==0) {
>			
>			// 현재 카드의 배치를 숫자로 변환 한다 
>			int current = Integer.parseInt(new String(numbers));
>			
>			// 만들어진 숫자가 기존의 정답보다 크다면 갱신한다
>			if(current > result)
>				result = current;
>			
>			return;
>			
>		}
>
>		// 교환 횟수만큼 가능한 모든 교환을 진행한다
>		for(int i=start; i<numbers.length-1; ++i) 
>			for(int j=i+1; j<numbers.length; ++j) {
>				
>				// 교환 횟수 1을 소모 하여 i, j 위치의 카드들을 교환한뒤 다음 교환을 진행한다
>				char temp = numbers[i];
>				numbers[i] = numbers[j];
>				numbers[j] = temp;
>
>				// -----------------------------------------------------------------
>				// ----------- 2. 이미 나왔던 배치의 재탐색을 제외한다. ------------
>				dfs(cnt-1, i, numbers);
>				// -----------------------------------------------------------------
>
>				numbers[j] = numbers[i];
>				numbers[i] = temp;
>				
>			}
>		
>	}
>	
>}
>```

<br/>

---

<br/>

## iii. 풀이
	* 문제요약 *
	
	N개의 숫자가 순서대로 주어지고
	반드시 교환해야 되는 횟수 C가 주어졌을 때
	만들수 있는 최대 상금

단순히 완전탐색을 수행하면 최악의 경우 N = 6, C = 10 일때
5!^10 이라는 매우 큰 경우의 수를 탐색해야 한다.

따라서 그리디적인 방법을 사용하여 교환 횟수와 탐색 횟수를 사전에 줄여줘야 한다.

<br/>

#### ***1. 완전 탐색을 시작하기 전 의미없는 교환 횟수를 제거한다.***
	* 단서 1 *
 	
	C 횟수로 만들 수 있는 최대상금은
 	N-1 이하의 횟수로 만들 수 있다.
증명
* C 횟수를 교환하여 만들 수 있는 최대 상금의 배치를 A B C ... 라고 한다면
처음 받은 숫자의 배치가 어떻든지 간에
최대 상금 배치에서의 A의 위치가 처음 배치에서 어느 위치에 있든 한 번 이하의 교환으로 바로 A의 위치로 옮길 수 있다.
마찬가지로 그 다음
최대 상금 배치에서의 B의 위치가 처음 배치에서 어느 위치에 있든 한 번 이하의 교환으로 바로 A의 위치로 옮길 수 있다.
동일하게 계속 진행한다면
최대 N-1 번째 교환에서 최대 상금의 배치는 무조건 만들 수 있다.

<br/><br/>

	* 단서 2 *
 	
	C 횟수로 만들 수 있는 최대상금은
	C-2 횟수로 만들 수 있는 최대상금보다 작을 수 없다.
증명
* C-2 횟수의 최대상금이 C 횟수의 최대상금보다 크다면
그 C-2 횟수의 최대상금의 배치에서 임의의 두 수를 한 번 서로 바꾸고 그 다음 똑같이 그 수들을 다시 서로 바꾼다면
C 횟수만큼 사용하여 C-2횟수만큼 사용했을때 만들 수 있는 최대상금을 만들 수 있게 된다.
따라서 C 횟수의 최대상금은 C-2의 최대상금보다 작을 수 없다.

<br/><br/>

	* 단서 3 *
 	
	C 횟수로 만들 수 있는 카드의 배치는
	C-1 횟수로 만들 수 없다.
증명
* 1회로 만들 수 있는 카드의 배치는 0회로 만들 수 없다는 것을 공리라고 했을때 어떤 C 횟수로 만들 수 있는 카드의 배치가 어떤 C-1 횟수로 만들 수 있게 된다면 그 어떤 C 횟수로 만들 수 있는 카드의 배치를 C-1 횟수로 만든 뒤 또 한 번 교환해서 만들 수 있는 모든 배치를 C 횟수로 만든다면 C 횟수로 만들 수 있는 배치에 그 어떤 C 횟수로 만들 수 있는 배치와 그 배치의 직전 교환에 가능한 모든 배치 즉 C-1횟수로 만들 수 있는 모든 배치가 포함되게 된다. 그렇게 된다면 또 이어서 c-2횟수로 만들 수 있는 모든 배치가 c-1횟수로 만들 수 있다는 뜻이되고 결국 공리인 0회로 만들 수 있는 배치가 1회로 만들 수 있다는 명제까지 오게되므로 이는 모순이 된다.

<br/><br/>

	* 결론 *
 	
	단서들을 조합하여 C-2가 N-1보다 클 경우
 	C의 최대상금은 C-2의 최대상금과 같다는 것을 알 수 있으며
  	따라서 N-1이하의 C-2n 중 가장 큰 교환횟수의 최대상금이 C의 최대상금과 같다는 것을 알 수 있다.

<br/><br/>

### ***2. 이미 나왔던 배치의 재탐색을 제외한다.***

	현재까지의 교환으로 바뀐 숫자의 배치들은 가장 왼쪽카드 부터의 교환으로 무조건 만들어질 수 있다.
증명

현재까지 바뀐 카드의 수를 n, 현재까지 교환한 횟수를 c라고 하면 c는 n-1보다 클 수밖에 없고 그렇다면 바뀐 뒤의 n의 배치가 처음에 어떤 배치였던지 간에 위 1의 첫번째 증명에서 보았던 것과 같이 교환 위치를 왼쪽부터 우선하여 만들 수 있다.

### ***따라서 다음 교환의 첫번째 카드의 위치를 이전 교환까지의 첫번째 카드의 위치 이전 부터 교환하는 것은 그 이전에 이미 나온 배치일 것이므로 다음교환의 첫번째 카드의 시작 위치는 현재교환의 첫번째 카드의 위치부터만 고려하면 된다.***

<br/>

---

<br/>

## iv. 추가

``` Java
	if(numbers.length<cnt)
		cnt = numbers.length;
```

인터넷에는 탐색을 시작하기 전 교환횟수를 줄여주는 로직으로 위와 같은 조건문이 많이 돌아다닌다.<br>
하지만 이는 정답 테스트 케이스에는 포함되지 않는 반례가 존재한다.<br>
예를들어 입력으로 주어진 카드가 49 이고 교환 횟수가 3으로 주어진다면 최대 상금은 94이지만 위 로직을 사용하면 49라고 출력된다.<br>
이는 처음 코드를 작성한 사람과 그 이후에 참고한 사람들이 왜 일정교환 횟수 이상이 의미가 없는 것인지에 대한 명확한 이해가 없이 로직을 작성했고 그 로직의 반례를 우연치 않게 정답 테스트 케이스가 포함하지 못했기 때문인 것으로 보인다.<br>
***위 로직이 잘못된 이유는 줄어든 횟수가 홀수인 경우가 생기기 때문이다***<br>
위 1의 증명에서 C의 최대상금은 C-2의 최대상금과 동일하다는 것을 증명했지만 C의 최대 상금이 C-1의 최대상금과 동일하다고 하지 않았다.<br>
그 이유는 C-1의 최대상금이 C의 최대상금보다 클 수 있기 때문이다.<br>
<br>
C의 교환횟수로 만들 수 있는 최대 상금은 항상 내림차순으로 정렬된 숫자가 아니다.<br>
C의 교환횟수로 만들 수 있는 최대 상금이 내림차순으로 정렬된 숫자가 아니라면 C+1의 교환횟수로 만들 수 있는 최대상금이 C로 만든 최대 상금보다 클 수밖에 없다.<br>
C로 만든 최대상금의 내림차순이 아닌 오름차순인 부분을 다시 서로 바꿔주기만하면 되기 때문이다.<br>
그 C+1의 교환 횟수로 만들 수 있는 최대상금은 C-1과 같다 따라서 C-1의 최대상금은 C의 최대상금보다 클 수 있다.<br>
***따라서 교환횟수를 짝수가 아닌 홀수횟수만큼 줄이는 경우 최대상금이 변경되는 결과를 가져올 수 있으므로 잘못된 로직이다.***
